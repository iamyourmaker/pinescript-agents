//@version=6
strategy("TPO/Market Profile + Order Blocks - Futures Strategy",
     shorttitle="TPO-OB",
     overlay=true,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=10,
     commission_type=strategy.commission.percent,
     commission_value=0.04,
     slippage=2,
     calc_on_every_tick=false,
     calc_on_order_fills=false,
     pyramiding=0)

// ============================================================================
// INPUTS - Futures Presets and Session Settings
// ============================================================================

// Futures Contract Presets
futuresPreset = input.string("Custom", "Futures Contract Preset",
     options=["Custom", "NQ (Nasdaq)", "ES (S&P 500)", "GC (Gold)", "CL (Crude Oil)"],
     group="Futures Contract Settings",
     tooltip="Select a preset for popular futures contracts or use Custom")

// Session Time Inputs (Custom)
customSession = input.session("0930-1600", "Custom Session Time",
     group="Futures Contract Settings",
     tooltip="Define custom session time (e.g., 0930-1600 for regular US market hours)")

useCustomSession = input.bool(false, "Use Custom Session (Override Preset)",
     group="Futures Contract Settings")

// Get session based on preset or custom
getSessionTime() =>
    if useCustomSession
        customSession
    else
        switch futuresPreset
            "NQ (Nasdaq)" => "0930-1600"
            "ES (S&P 500)" => "0930-1600"
            "GC (Gold)" => "0820-1330"
            "CL (Crude Oil)" => "0900-1430"
            => "0930-1600"

sessionTime = getSessionTime()

// TPO Settings
tpoMethod = input.string("Time-Based", "TPO Calculation Method",
     options=["Time-Based", "Volume-Weighted"],
     group="TPO/Market Profile Settings",
     tooltip="Time-Based uses price bars, Volume-Weighted incorporates volume")

tpoPeriod = input.int(30, "TPO Period (minutes)",
     minval=1,
     maxval=240,
     group="TPO/Market Profile Settings",
     tooltip="Time period for each TPO calculation")

valueAreaPercent = input.float(70.0, "Value Area %",
     minval=50,
     maxval=90,
     step=5,
     group="TPO/Market Profile Settings",
     tooltip="Percentage of volume/time for value area calculation (default 70%)")

showInitialBalance = input.bool(true, "Show Initial Balance",
     group="TPO/Market Profile Settings",
     tooltip="Display first hour high/low range")

ibPeriodMinutes = input.int(60, "Initial Balance Period (minutes)",
     minval=30,
     maxval=120,
     step=30,
     group="TPO/Market Profile Settings")

// Order Block Settings
obSensitivity = input.int(3, "Order Block Sensitivity",
     minval=2,
     maxval=10,
     group="Order Block Settings",
     tooltip="Minimum consecutive candles for order block validation")

obMinBodyPercent = input.float(30.0, "Min Body % for OB Candle",
     minval=10,
     maxval=90,
     step=10,
     group="Order Block Settings",
     tooltip="Minimum body size as % of candle range")

maxOrderBlocks = input.int(5, "Max Active Order Blocks",
     minval=1,
     maxval=20,
     group="Order Block Settings",
     tooltip="Maximum number of order blocks to track")

obValidityBars = input.int(50, "Order Block Validity (bars)",
     minval=10,
     maxval=200,
     group="Order Block Settings",
     tooltip="Maximum bars to keep an order block active")

requireVolumeConfirmation = input.bool(true, "Require Volume Confirmation",
     group="Order Block Settings",
     tooltip="Require above-average volume for order block formation")

// Trading Logic
longConditionType = input.string("OB + VAL", "Long Entry Condition",
     options=["OB + VAL", "OB + POC", "OB + Value Area", "OB Only"],
     group="Trading Logic",
     tooltip="Condition type for long entries")

shortConditionType = input.string("OB + VAH", "Short Entry Condition",
     options=["OB + VAH", "OB + POC", "OB + Value Area", "OB Only"],
     group="Trading Logic",
     tooltip="Condition type for short entries")

minDistanceToTPO = input.float(0.5, "Min Distance to TPO Level (%)",
     minval=0,
     maxval=5,
     step=0.1,
     group="Trading Logic",
     tooltip="Minimum distance from order block to TPO level for entry")

// Risk Management
stopLossMethod = input.string("Order Block Size", "Stop Loss Method",
     options=["Order Block Size", "ATR", "Fixed %"],
     group="Risk Management",
     tooltip="Method for calculating stop loss")

stopLossATRMultiplier = input.float(1.5, "ATR Multiplier (if ATR)",
     minval=0.5,
     maxval=5,
     step=0.5,
     group="Risk Management")

stopLossPercent = input.float(1.0, "Fixed Stop Loss %",
     minval=0.1,
     maxval=10,
     step=0.1,
     group="Risk Management")

takeProfitMethod = input.string("VAH/VAL", "Take Profit Method",
     options=["VAH/VAL", "Risk:Reward", "Fixed %", "POC"],
     group="Risk Management",
     tooltip="Method for calculating take profit")

riskRewardRatio = input.float(2.0, "Risk:Reward Ratio",
     minval=0.5,
     maxval=10,
     step=0.5,
     group="Risk Management")

takeProfitPercent = input.float(2.0, "Fixed Take Profit %",
     minval=0.1,
     maxval=20,
     step=0.1,
     group="Risk Management")

maxTradesPerSession = input.int(3, "Max Trades Per Session",
     minval=1,
     maxval=20,
     group="Risk Management")

useSessionExit = input.bool(true, "Exit at Session End",
     group="Risk Management",
     tooltip="Close all positions at end of trading session")

// Visualization
showVAH = input.bool(true, "Show Value Area High",
     group="Visualization")

showVAL = input.bool(true, "Show Value Area Low",
     group="Visualization")

showPOC = input.bool(true, "Show Point of Control",
     group="Visualization")

showOrderBlocks = input.bool(true, "Show Order Blocks",
     group="Visualization")

showEntryExitMarkers = input.bool(true, "Show Entry/Exit Markers",
     group="Visualization")

showStatsTable = input.bool(true, "Show Statistics Table",
     group="Visualization")

// Colors
colorVAH = input.color(color.new(color.red, 50), "VAH Color",
     group="Colors")

colorVAL = input.color(color.new(color.green, 50), "VAL Color",
     group="Colors")

colorPOC = input.color(color.new(color.orange, 30), "POC Color",
     group="Colors")

colorBullishOB = input.color(color.new(color.green, 80), "Bullish Order Block",
     group="Colors")

colorBearishOB = input.color(color.new(color.red, 80), "Bearish Order Block",
     group="Colors")

// ============================================================================
// SESSION DETECTION
// ============================================================================

isInSession = not na(time(timeframe.period, sessionTime))
isNewSession = ta.change(time(timeframe.period, sessionTime))

// Session tracking
var int sessionBarCount = 0
var float sessionHigh = na
var float sessionLow = na
var float sessionOpen = na

if isNewSession
    sessionBarCount := 0
    sessionHigh := high
    sessionLow := low
    sessionOpen := open
else if isInSession
    sessionBarCount += 1
    sessionHigh := math.max(sessionHigh, high)
    sessionLow := math.min(sessionLow, low)

// ============================================================================
// TPO/MARKET PROFILE CALCULATIONS
// ============================================================================

// Price levels for TPO calculation
var array<float> tpoPrices = array.new<float>()
var array<int> tpoVolumes = array.new<int>()
var array<int> tpoTimes = array.new<int>()

// Reset arrays at new session
if isNewSession
    array.clear(tpoPrices)
    array.clear(tpoVolumes)
    array.clear(tpoTimes)

// Calculate tick size for the symbol
tickSize = syminfo.mintick

// Add current bar data to TPO
if isInSession
    priceRange = high - low
    numTicks = math.max(1, math.round(priceRange / tickSize))

    for i = 0 to int(math.min(numTicks, 100))
        price = low + (i * tickSize)

        if price <= high and price >= low
            idx = -1

            for j = 0 to array.size(tpoPrices) - 1
                if math.abs(array.get(tpoPrices, j) - price) < tickSize / 2
                    idx := j
                    break

            if idx >= 0
                if tpoMethod == "Volume-Weighted"
                    array.set(tpoVolumes, idx, array.get(tpoVolumes, idx) + int(volume / numTicks))
                else
                    array.set(tpoTimes, idx, array.get(tpoTimes, idx) + 1)
            else
                array.push(tpoPrices, price)
                array.push(tpoVolumes, tpoMethod == "Volume-Weighted" ? int(volume / numTicks) : 0)
                array.push(tpoTimes, tpoMethod == "Time-Based" ? 1 : 0)

// Calculate POC, VAH, VAL
var float poc = na
var float vah = na
var float val = na

if isInSession and array.size(tpoPrices) > 0
    maxActivity = 0
    pocIndex = 0

    for i = 0 to array.size(tpoPrices) - 1
        activity = tpoMethod == "Volume-Weighted" ? array.get(tpoVolumes, i) : array.get(tpoTimes, i)

        if activity > maxActivity
            maxActivity := activity
            pocIndex := i

    poc := array.get(tpoPrices, pocIndex)

    totalActivity = 0
    for i = 0 to array.size(tpoPrices) - 1
        totalActivity += tpoMethod == "Volume-Weighted" ? array.get(tpoVolumes, i) : array.get(tpoTimes, i)

    targetActivity = totalActivity * (valueAreaPercent / 100)

    // Sort prices by activity to find value area
    var array<float> sortedPrices = array.new<float>()
    var array<int> sortedActivity = array.new<int>()

    array.clear(sortedPrices)
    array.clear(sortedActivity)

    for i = 0 to array.size(tpoPrices) - 1
        array.push(sortedPrices, array.get(tpoPrices, i))
        array.push(sortedActivity, tpoMethod == "Volume-Weighted" ? array.get(tpoVolumes, i) : array.get(tpoTimes, i))

    // Simple bubble sort by activity
    n = array.size(sortedActivity)
    for i = 0 to n - 2
        for j = 0 to n - i - 2
            if array.get(sortedActivity, j) < array.get(sortedActivity, j + 1)
                tempActivity = array.get(sortedActivity, j)
                tempPrice = array.get(sortedPrices, j)
                array.set(sortedActivity, j, array.get(sortedActivity, j + 1))
                array.set(sortedActivity, j + 1, tempActivity)
                array.set(sortedPrices, j, array.get(sortedPrices, j + 1))
                array.set(sortedPrices, j + 1, tempPrice)

    // Find value area by taking top prices until we hit target
    accumulatedActivity = 0
    var array<float> valueAreaPrices = array.new<float>()
    array.clear(valueAreaPrices)

    for i = 0 to array.size(sortedActivity) - 1
        if accumulatedActivity < targetActivity
            array.push(valueAreaPrices, array.get(sortedPrices, i))
            accumulatedActivity += array.get(sortedActivity, i)
        else
            break

    if array.size(valueAreaPrices) > 0
        vah := array.max(valueAreaPrices)
        val := array.min(valueAreaPrices)

// Initial Balance
var float ibHigh = na
var float ibLow = na

ibPeriodBars = math.round(ibPeriodMinutes / timeframe.multiplier)

if isNewSession
    ibHigh := high
    ibLow := low
else if isInSession and sessionBarCount <= ibPeriodBars
    ibHigh := math.max(nz(ibHigh), high)
    ibLow := math.min(nz(ibLow, low), low)

// ============================================================================
// ORDER BLOCK DETECTION
// ============================================================================

// Order Block Type
type OrderBlock
    float top
    float bottom
    int startBar
    bool isBullish
    bool isValid

// Arrays to store order blocks
var array<OrderBlock> orderBlocks = array.new<OrderBlock>()

// Volume check
avgVolume = ta.sma(volume, 20)
isHighVolume = requireVolumeConfirmation ? volume > avgVolume : true

// Check for consecutive candles
consecutiveBullish = 0
consecutiveBearish = 0

for i = 0 to obSensitivity - 1
    if close[i] > open[i]
        consecutiveBullish += 1
    if close[i] < open[i]
        consecutiveBearish += 1

// Bullish Order Block: Last bearish candle before bullish move
isBearishCandle = close < open
bodyPercent = math.abs(close - open) / (high - low) * 100
hasValidBody = bodyPercent >= obMinBodyPercent

bullishOBFormed = isBearishCandle and
     hasValidBody and
     isHighVolume and
     consecutiveBullish >= obSensitivity

// Bearish Order Block: Last bullish candle before bearish move
isBullishCandle = close > open

bearishOBFormed = isBullishCandle and
     hasValidBody and
     isHighVolume and
     consecutiveBearish >= obSensitivity

// Add new order blocks
if bullishOBFormed and isInSession
    newOB = OrderBlock.new(high, low, bar_index, true, true)
    array.push(orderBlocks, newOB)

    if array.size(orderBlocks) > maxOrderBlocks
        array.shift(orderBlocks)

if bearishOBFormed and isInSession
    newOB = OrderBlock.new(high, low, bar_index, false, true)
    array.push(orderBlocks, newOB)

    if array.size(orderBlocks) > maxOrderBlocks
        array.shift(orderBlocks)

// Update order block validity
for i = 0 to array.size(orderBlocks) - 1
    ob = array.get(orderBlocks, i)

    barsActive = bar_index - ob.startBar

    if barsActive > obValidityBars
        ob.isValid := false

    if ob.isBullish and low < ob.bottom
        ob.isValid := false

    if not ob.isBullish and high > ob.top
        ob.isValid := false

    array.set(orderBlocks, i, ob)

// ============================================================================
// TRADING LOGIC
// ============================================================================

// Find nearest valid order blocks
var float nearestBullishOBBottom = na
var float nearestBullishOBTop = na
var float nearestBearishOBBottom = na
var float nearestBearishOBTop = na

nearestBullishOBBottom := na
nearestBullishOBTop := na
nearestBearishOBBottom := na
nearestBearishOBTop := na

for i = 0 to array.size(orderBlocks) - 1
    ob = array.get(orderBlocks, i)

    if ob.isValid
        if ob.isBullish
            if na(nearestBullishOBBottom) or (close >= ob.bottom and close <= ob.top)
                nearestBullishOBBottom := ob.bottom
                nearestBullishOBTop := ob.top
        else
            if na(nearestBearishOBBottom) or (close >= ob.bottom and close <= ob.top)
                nearestBearishOBBottom := ob.bottom
                nearestBearishOBTop := ob.top

// Check if price is at order block
atBullishOB = not na(nearestBullishOBBottom) and
     low <= nearestBullishOBTop and
     high >= nearestBullishOBBottom

atBearishOB = not na(nearestBearishOBBottom) and
     low <= nearestBearishOBTop and
     high >= nearestBearishOBBottom

// Check distance to TPO levels
distanceToVAL = not na(val) ? math.abs(close - val) / close * 100 : 100.0
distanceToVAH = not na(vah) ? math.abs(close - vah) / close * 100 : 100.0
distanceToPOC = not na(poc) ? math.abs(close - poc) / close * 100 : 100.0

// Long conditions
nearVAL = distanceToVAL <= minDistanceToTPO
nearPOC = distanceToPOC <= minDistanceToTPO
inValueArea = not na(val) and not na(vah) and close >= val and close <= vah

longTPOCondition = switch longConditionType
    "OB + VAL" => nearVAL or (not na(val) and close <= val)
    "OB + POC" => nearPOC or (not na(poc) and close <= poc)
    "OB + Value Area" => inValueArea or (not na(val) and close <= val)
    "OB Only" => true
    => false

// Short conditions
nearVAH = distanceToVAH <= minDistanceToTPO

shortTPOCondition = switch shortConditionType
    "OB + VAH" => nearVAH or (not na(vah) and close >= vah)
    "OB + POC" => nearPOC or (not na(poc) and close >= poc)
    "OB + Value Area" => inValueArea or (not na(vah) and close >= vah)
    "OB Only" => true
    => false

// Final entry conditions
longCondition = atBullishOB and longTPOCondition and isInSession
shortCondition = atBearishOB and shortTPOCondition and isInSession

// ============================================================================
// RISK MANAGEMENT CALCULATIONS
// ============================================================================

atr = ta.atr(14)

// Calculate stop loss
calcStopLoss(isLong, entryPrice) =>
    sl = switch stopLossMethod
        "Order Block Size" => isLong ? nearestBullishOBBottom : nearestBearishOBTop
        "ATR" => isLong ? entryPrice - (atr * stopLossATRMultiplier) : entryPrice + (atr * stopLossATRMultiplier)
        "Fixed %" => isLong ? entryPrice * (1 - stopLossPercent / 100) : entryPrice * (1 + stopLossPercent / 100)
        => isLong ? entryPrice * 0.99 : entryPrice * 1.01
    sl

// Calculate take profit
calcTakeProfit(isLong, entryPrice, stopLoss) =>
    tp = switch takeProfitMethod
        "VAH/VAL" => isLong ? vah : val
        "Risk:Reward" => isLong ? entryPrice + (math.abs(entryPrice - stopLoss) * riskRewardRatio) : entryPrice - (math.abs(entryPrice - stopLoss) * riskRewardRatio)
        "Fixed %" => isLong ? entryPrice * (1 + takeProfitPercent / 100) : entryPrice * (1 - takeProfitPercent / 100)
        "POC" => poc
        => isLong ? entryPrice * 1.02 : entryPrice * 0.98
    tp

// Track trades per session
var int tradesThisSession = 0

if isNewSession
    tradesThisSession := 0

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================

// Check if we can take more trades
canTrade = tradesThisSession < maxTradesPerSession

// Long Entry
if longCondition and strategy.position_size == 0 and canTrade and barstate.isconfirmed
    stopLoss = calcStopLoss(true, close)
    takeProfit = calcTakeProfit(true, close, stopLoss)

    strategy.entry("Long", strategy.long)
    strategy.exit("Long Exit", "Long",
         stop=stopLoss,
         limit=takeProfit)

    tradesThisSession += 1

// Short Entry
if shortCondition and strategy.position_size == 0 and canTrade and barstate.isconfirmed
    stopLoss = calcStopLoss(false, close)
    takeProfit = calcTakeProfit(false, close, stopLoss)

    strategy.entry("Short", strategy.short)
    strategy.exit("Short Exit", "Short",
         stop=stopLoss,
         limit=takeProfit)

    tradesThisSession += 1

// Session end exit
if useSessionExit and not isInSession and strategy.position_size != 0
    strategy.close_all("Session End")

// ============================================================================
// VISUALIZATION
// ============================================================================

// Plot TPO Levels
plot(showVAH and vah ? vah : na, "VAH",
     color=colorVAH,
     linewidth=2,
     style=plot.style_line)

plot(showVAL and val ? val : na, "VAL",
     color=colorVAL,
     linewidth=2,
     style=plot.style_line)

plot(showPOC and poc ? poc : na, "POC",
     color=colorPOC,
     linewidth=3,
     style=plot.style_line)

// Plot Initial Balance
plot(showInitialBalance and ibHigh ? ibHigh : na, "IB High",
     color=color.new(color.blue, 70),
     linewidth=1,
     style=plot.style_stepline)

plot(showInitialBalance and ibLow ? ibLow : na, "IB Low",
     color=color.new(color.blue, 70),
     linewidth=1,
     style=plot.style_stepline)

// Draw Order Blocks
if showOrderBlocks
    for i = 0 to array.size(orderBlocks) - 1
        ob = array.get(orderBlocks, i)

        if ob.isValid
            obColor = ob.isBullish ? colorBullishOB : colorBearishOB

            box.new(ob.startBar, ob.top, bar_index + 1, ob.bottom,
                 border_color=color.new(obColor, 50),
                 bgcolor=obColor,
                 extend=extend.right)

// Entry/Exit Markers
if showEntryExitMarkers
    plotshape(longCondition and canTrade and barstate.isconfirmed, "Long Entry",
         shape.triangleup,
         location.belowbar,
         color.new(color.green, 0),
         size=size.small)

    plotshape(shortCondition and canTrade and barstate.isconfirmed, "Short Entry",
         shape.triangledown,
         location.abovebar,
         color.new(color.red, 0),
         size=size.small)

// Statistics Table
if showStatsTable and barstate.islast
    var table statsTable = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 85), border_width=1)

    table.cell(statsTable, 0, 0, "Metric", text_color=color.white, bgcolor=color.new(color.gray, 70))
    table.cell(statsTable, 1, 0, "Value", text_color=color.white, bgcolor=color.new(color.gray, 70))

    table.cell(statsTable, 0, 1, "Futures", text_color=color.white)
    table.cell(statsTable, 1, 1, futuresPreset, text_color=color.yellow)

    table.cell(statsTable, 0, 2, "POC", text_color=color.white)
    table.cell(statsTable, 1, 2, not na(poc) ? str.tostring(poc, format.mintick) : "N/A", text_color=color.orange)

    table.cell(statsTable, 0, 3, "VAH", text_color=color.white)
    table.cell(statsTable, 1, 3, not na(vah) ? str.tostring(vah, format.mintick) : "N/A", text_color=color.red)

    table.cell(statsTable, 0, 4, "VAL", text_color=color.white)
    table.cell(statsTable, 1, 4, not na(val) ? str.tostring(val, format.mintick) : "N/A", text_color=color.green)

    table.cell(statsTable, 0, 5, "Active OBs", text_color=color.white)

    validOBCount = 0
    for i = 0 to array.size(orderBlocks) - 1
        if array.get(orderBlocks, i).isValid
            validOBCount += 1

    table.cell(statsTable, 1, 5, str.tostring(validOBCount), text_color=color.aqua)

    table.cell(statsTable, 0, 6, "Session Trades", text_color=color.white)
    table.cell(statsTable, 1, 6, str.tostring(tradesThisSession) + "/" + str.tostring(maxTradesPerSession), text_color=color.yellow)

    table.cell(statsTable, 0, 7, "In Session", text_color=color.white)
    table.cell(statsTable, 1, 7, isInSession ? "YES" : "NO", text_color=isInSession ? color.green : color.red)

    table.cell(statsTable, 0, 8, "Net Profit", text_color=color.white)
    table.cell(statsTable, 1, 8, str.tostring(strategy.netprofit, format.mintick), text_color=strategy.netprofit >= 0 ? color.green : color.red)

    table.cell(statsTable, 0, 9, "Win Rate", text_color=color.white)
    winRate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0
    table.cell(statsTable, 1, 9, str.tostring(winRate, "#.##") + "%", text_color=winRate >= 50 ? color.green : color.red)

// ============================================================================
// ALERTS
// ============================================================================

alertcondition(longCondition and canTrade, "Long Entry Signal", "TPO-OB Long Entry: Price at Bullish Order Block near {{plot_0}}")
alertcondition(shortCondition and canTrade, "Short Entry Signal", "TPO-OB Short Entry: Price at Bearish Order Block near {{plot_1}}")
